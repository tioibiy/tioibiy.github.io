[{"title":"P10173题解","url":"/2024/02/28/P10173题解/","content":"\n# P10173 maxiMINImax\n\n[题目传送门](https://www.luogu.com.cn/problem/P10173)\n\n## 思路：\n\n题目要求对符合要求的区间进行计数，而判断一个区间是否符合要求，只和这个区间的最大/最小值有关，所以考虑每个 $a_i$ 能在哪些区间成为最大/最小值，然后枚举中间的区间最小值，用树状数组对两侧区间的信息整合。\n\n1. 单调队列处理出每个 $a_i$ 两侧，第一个比它大和比它小的点的下标，记为 $lb_i,ls_i,rb_i,rs_i$，其中 $l,r$ 表示左右，$b,s$ 表示比 $a_i$ 大/小。\n\n\t注：若找不到比 $a_i$ 大/小的，即 $a_i$ 左/右的数全都比 $a_i$ 小/大，则记为数列边界，左侧为 $0$ ，右侧为 $n+1$ 。\n\n2. 计算以 $a_i$ 为最小值的区间数量 $x_i=(i-ls_i)(rs_i-i)$ ，以 $a_i$ 为最大值则记为 $y_i=(i-lb_i)(rb_i-i)$。\n\n3. 所求 $ans$ 即可表示为：\n\n\t$$\n    ans=\\sum_{1<i<n}\\sum_{1\\le j<i,a_j<a_i}\\sum_{i<k\\le n,a_k<a_i}\n    (a_i-a_j)(a_i-a_k)x_iy_jy_k\n    $$\n\n    方便起见，用 $\\sum_{i},\\sum_{j},\\sum_{k}$ 代指 $\\sum_{1<i<n},\\sum_{1\\le j<i,a_j<a_i},\\sum_{i<k\\le n,a_k<a_i}$，亦即枚举符合条件的三区间极值。\n\n    - 注：由于 $a_i>a_j,a_k$，则“以 $a_i$ 为最小值的区间”，与“以 $a_j,a_k$ 为最大值的区间”不可能重合，不影响计数。\n\n    $$\n    \\begin{aligned}\n        ans\n        &=\\sum_{i}\\sum_{j}\\sum_{k}\n        (a_i-a_j)(a_i-a_k)x_iy_jy_k\\\\\n        &=\\sum_{i}x_i\\sum_{j}\\sum_{k}\n        \\left[a_i^2-a_i\\left(a_j+a_k\\right)+a_ja_k\\right]y_jy_k\\\\\n        &=\\sum_{i}x_i\n        \\left[\n            a_i^2\\sum_{j}\\sum_{k}y_jy_k-\n            a_i\\sum_{j}\\sum_{k}\n            \\left(a_j+a_k\\right)y_jy_k+\n            \\sum_{j}\\sum_{k}a_ja_ky_jy_k\n        \\right]\\\\\n        &=\\sum_{i}x_i\n        \\left[\n            a_i^2\\sum_{j}\\sum_{k}y_jy_k-\n            a_i\n            \\left(\n                \\sum_{j}\\sum_{k}\n                a_jy_jy_k+\n                \\sum_{j}\\sum_{k}\n                a_ky_jy_k\n            \\right)+\n            \\sum_{j}\\sum_{k}a_jy_ja_ky_k\n        \\right]\n    \\end{aligned}\n    $$\n\n    - 注意到：对于数列 $\\{a_n\\},\\{b_n\\}$\n        $$\\sum_{i}\\sum_{j}a_ib_j=\\sum_{i}\\left(a_i\\sum_{j}b_j\\right)=\\left(\\sum_{i}a_i\\right)\\left(\\sum_{j}b_j\\right)$$\n\n    $$\n    \\begin{aligned}\n        ans\n        &=\\sum_{i}x_i\n        \\left[\n            a_i^2\\left(\\sum_{j}y_j\\right)\\left(\\sum_{k}y_k\\right)-\n            a_i\\left[\n                \\left(\\sum_{j}a_jy_j\\right)\\left(\\sum_{k}y_k\\right)+\n                \\left(\\sum_{j}y_j\\right)\\left(\\sum_{k}a_ky_k\\right)\n            \\right]+\n            \\left(\\sum_{j}a_jy_j\\right)\\left(\\sum_{k}a_ky_k\\right)\n        \\right]\n    \\end{aligned}\n    $$\n\n    化简过程中应尽可能将 $j,k$ 有关的项分离，使之可以被树状数组维护，即避免出现 $\\sum_{j}\\sum_{k}f(j)g(k)$ 的出现。\n\n4. 到此为止，我们已经通过树状数组维护 $\\sum_{j}y_j,\\sum_{k}y_k,\\sum_{j}a_jy_j,\\sum_{k}a_ky_k$ 来计算 $ans$ 了，但是上式还可以继续化简使得代码更加简洁，记\n   \n    $$\n    \\begin{aligned}\n    L_y&(i)&=&\\sum_{j}y_j\\\\\n    R_y&(i)&=&\\sum_{k}y_k\\\\\n    L_{ay}&(i)&=&\\sum_{j}a_jy_j\\\\\n    R_{ay}&(i)&=&\\sum_{k}a_ky_k\n    \\end{aligned}\n    $$\n\n    则 $ans$ 可简写为：\n\n    $$\n    \\begin{aligned}\n        ans\n        &=\\sum_{i}x_i\n        \\left[\n            a_i^2L_y(i)R_y(i)-\n            a_i\\left[L_{ay}(i)R_y(i)+L_y(i)R_{ay}(i)\\right]+\n            L_{ay}(i)R_{ay}(i)\n        \\right]\n    \\end{aligned}\n    $$\n\n    观察各项系数\n\n    ||$L_y(i)$|$L_{ay}(i)$|\n    |:---:|:---:|:---:|\n    |$R_y(i)$|$a_i^2$|$-a_i$|\n    |$R_{ay}(i)$|$-a_i$|$1$|\n\n    可因式分解\n    \n    $$\n    \\begin{aligned}\n        ans\n        &=\\sum_{i}x_i\n        \\left[\n            a_iL_y(i)-L_{ay}(i)\n        \\right]\n        \\left[\n            a_iR_y(i)-R_{ay}(i)\n        \\right]\n    \\end{aligned}\n    $$\n\n    在从左到右枚举 $i$ 的同时，把树状数组当作桶数组使用，以 $a_i$ 为关键字，把 $y_i,a_iy_i$ 放进相应的桶里，同时支持查询 $i$ 左/右侧比 $a_i$ 小的 $L,R$，就可以 $O(n\\log n)$ 地计算 $ans$ 了。\n\n## 代码\n\n```cpp\n#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int N=1e6+5,p=9712176;\nint n,a[N],lb[N],ls[N],rb[N],rs[N],x[N],y[N],ans;\nstruct tree{\n    int data[N+10]={};\n    inline int lowbit(int x){return x&-x;}\n    void add(int i,int x){while(i<=N-5)data[i]+=x,i+=lowbit(i);}\n    int sum(int i){int ans=0;while(i)ans+=data[i],i-=lowbit(i);return ans;}\n}l1,r1,l2,r2;\nvoid init(bool flag,function<bool(int a,int b)> cmp,int *ans){\n    stack<int> stk;\n    stk.push(flag?n+1:0);\n    for(int i=flag?n:1;flag?i>=1:i<=n;flag?i--:i++){\n        while(!cmp(a[stk.top()],a[i])&&stk.size()>1)stk.pop();\n        ans[i]=stk.top();\n        stk.push(i);\n    }\n}\nsigned main(){\n    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n    cin>>n;\n    for(int i=1;i<=n;i++) cin>>a[i];\n    init(0,[](int a,int b){return a<b;},ls);\n    init(0,[](int a,int b){return a>b;},lb);\n    init(1,[](int a,int b){return a<b;},rs);\n    init(1,[](int a,int b){return a>b;},rb);\n    for(int i=1;i<=n;i++) x[i]=(i-ls[i])%p*(rs[i]-i)%p,y[i]=(i-lb[i])%p*(rb[i]-i)%p;\n    for(int i=1;i<=n;i++){r1.add(a[i],y[i]%p);r2.add(a[i],a[i]*y[i]%p);}\n    for(int i=1;i<=n;i++){\n        a[i]%=p;\n        (ans+=x[i]%p*(a[i]*l1.sum(a[i]-1)%p-l2.sum(a[i]-1)%p+p)%p*(a[i]*r1.sum(a[i]-1)%p-r2.sum(a[i]-1)%p+p)%p)%=p;\n        l1.add(a[i],y[i]%p);l2.add(a[i],a[i]*y[i]%p);\n        r1.add(a[i],-y[i]%p);r2.add(a[i],-a[i]*y[i]%p);\n    }\n    cout<<ans;\n    return 0;\n}\n```","tags":["题解"]},{"title":"CSP之后","url":"/2023/10/22/CSP之后/","content":"\n今年 $CSP$ 算是考完了……还有不到一个月 $NOIP$\n\n## $T_1$\n\n$\\mathbb{O}({10}^5n)$爆搜，预估$100$，实际$100$\n\n考场思路不够快，代码不够简洁，调试次数过多，需要增加简单题训练\n\n## $T_2$\n\n不到十分钟直接想到$dp$正解，复杂度$\\mathbb{O}(n)$\n\n说实话真没想到自己能很快想到，我认为这个$dp$的想法和正确性证明其实挺绕的。很害怕之后比赛里遇到这种难度的题，养成不打暴力直接想正解的习惯，最后写出一个不能回头的错解……\n\n## $T_3$\n\n大模拟……虽然之前做洛谷初赛题的时候查过`c++`里面`struct`和`union`的存储策略，但是还是没打出来，浪费两个半小时。预估$10$，实际$0$\n\n1. `STL`使用不熟练，包括`vetor`，`lower_bound()`，`map`，`pair`，`tuple`的基本操作以及`lambda`表达式的使用\n2. 打大模拟之前没有重新梳理和抽象自己的思路\n3. 没有系统地定义变量名，导致越调越慌，直接导致没有时间看$T_4$\n\n## $T_4$\n\n预估$5$，实际$0$\n\n看了眼题解，好像是图论+优先队列优化\n\n考场上读题不清，骗分的时候本来应该输出$n+1$，我搞成了$n$导致爆零，数学部分的分数也没拿到\n\n## 之后要补的东西及TODO\n\n- [ ] `STL`的使用\n- [ ] 学而思和洛谷回放\n- [ ] 订正月赛题目\n- [ ] `VScode`里洛谷和`cph Judge`插件的使用，整理以往题目\n- [ ] 补全算法，包括线段树，笛卡尔树，`BST`，高斯消元，逆元，割点，最小生成树，缩点，点/边双连通分量，匈牙利，树剖……\n- [ ] 补完$3D$模型$\\mathfrak{BUG}$以及各种博客（~~不可能的~~","tags":["计算机"]},{"title":"关于向量场","url":"/2023/10/02/关于向量场/","content":"\n1. 物理中流场、电场、磁场都可以用场线的密度判断场的大小。这是否对应了部分场所拥有的某性质？\n2. 有一向量场$\\boldsymbol{F}(\\boldsymbol{x})$，若其具有$1.$中的性质，是否能通过该向量场所有点对应向量的方向$\\frac{\\boldsymbol{F}(\\boldsymbol{x})}{|\\boldsymbol{F}(\\boldsymbol{x})|}$,确定每点对应向量的大小$|\\boldsymbol{F}(\\boldsymbol{x})|$?\n3. \n   给定一向量场$\\boldsymbol{F}(\\boldsymbol{x})$，从任意一点开始，不断向当前点对应向量的方向走一步，最终会形成一条折线。当每一步$\\Delta\\boldsymbol{x}$都很小的时候，形成的轨迹就会是这个向量场某条场线的一部分。试问，每次所走的步长相等，即\n   $$\\lim_{d \\to 0^+}\\Delta\\boldsymbol{x}=d\\frac{\\boldsymbol{F}(\\boldsymbol{x})}{|\\boldsymbol{F}(\\boldsymbol{x})|}$$\n   和每次步长都正比于所在位置向量的模长\n   $$\\lim_{d \\to 0^+}\\Delta\\boldsymbol{x}=d\\boldsymbol{F}(\\boldsymbol{x})$$\n   是否会对最终画出的场线产生影响？\n\n---\n\n我知道场线这东西的定义不怎么完备，但我也不想用散度旋度还有拉普拉斯算子什么的……就这样吧","tags":["数学","物理"]},{"title":"2023.8集训","url":"/2023/08/26/2023-8集训/","content":"\n$2023.8.14-2023.8.25$\n\n# 记一些集训过程中奇怪的想法\n\n1. 很多算法可以实现不同复杂度的不同操作。对于同一操作集合也有很多不同的算法来实现。比如，在规模为$n$的$RMQ$问题就有如下实现方式：\n   \n    | 算法 |预处理|单点修改|区间查询|空间复杂度|\n    |:---------:|:-----|:------|:-----|:-----|\n    |遍历|$\\Theta(n)$|$\\Theta(1)$|${\\rm O}(n)$|$\\Theta(n)$|\n    |$ST$表|$\\Theta(n)$|${\\rm O}(n)$|$\\Theta(1)$|$\\Theta(n\\log n)$|\n    |线段树|$\\Theta(n)$|$\\Theta(\\log n)$|${\\rm O}(\\log n)$|$\\Theta(n)$|\n    |树状数组|$\\Theta(n\\log n)$|${\\rm O}(\\log n)$|${\\rm O}(\\log n)$|$\\Theta(n)$|\n    |$Four Russian$|$\\Theta(n\\log\\log n)$|$\\Theta(\\frac{n}{\\log n})$|$\\Theta(1)$|$\\Theta(n\\log\\log n)$|\n\n    对于同一操作集合，列举实现它所有算法的$\\{预处理,单点修改,区间查询,空间复杂度\\cdots \\}$向量\n\n    {% note info %}\n    这个向量还可能包含更多元素，如均摊复杂度、最坏复杂度，还有排序算法中是否稳定等等……这个向量可以更长，甚至无限长\n    {% endnote %}\n\n    猜想这些向量在向量空间中分布与某超平面的一侧（包含这个超平面），其中位于超平面上的算法是在某些情况下复杂度最优的\n    \n    毕竟我们可以通过`while(1)`强行增加复杂度，所以这些向量组成的集合应是一个与向量空间同维度的“体”，而不是比向量空间维度更低的“面”或“线”。处于这个“体”的边界（也就是上文中的超平面）上的向量就是没有“复杂度损失”的算法\n\n    而不同实现操作集合的算法，其对应的超平面是否存在某种规律，是的我们经常观察到某些“优化”可以使某两个操作的复杂度从$({\\rm O}(n),{\\rm O}(1))$“优化”至$({\\rm O}(\\log n),{\\rm O}(\\log n))$？\n\n2. 内存可以看成是一个从有限自然数子集$A<{\\mathbb{N}}$到集合$\\{0,1\\}$的映射\n$$\nf:A\n$$","tags":["信奥","计算机"]},{"title":"数字孪生技术在文物保护方面的效果评估——游览项目","url":"/2023/06/04/数字孪生技术在文物保护方面的效果评估——游览项目/","content":"\n\n<html>\n<head>\n <meta charset=\"utf-8\">\n <title>3D Model in Markdown</title>\n <script src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js\"></script>\n</head>\n<body>\n <div id=\"three-container\"></div>\n\n <script>\n   function loadModel(url) {\n     return new Promise((resolve, reject) => {\n       const loader = new THREE.FileLoader();\n       loader.load(url, (model) => {\n         resolve(model);\n       }, (error) => {\n         reject(error);\n       });\n     });\n   }\n\n   async function init() {\n     const modelUrl = 'test.obj';\n\n     try {\n       const model = await loadModel(modelUrl);\n       const scene = new THREE.Scene();\n       const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);\n       camera.position.z = 5;\n\n       const renderer = new THREE.WebGLRenderer();\n       renderer.setSize(window.innerWidth, window.innerHeight);\n       document.getElementById('three-container').appendChild(renderer.domElement);\n\n       scene.add(model);\n\n       function animate() {\n         requestAnimationFrame(animate);\n         renderer.render(scene, camera);\n       }\n\n       animate();\n     } catch (error) {\n       console.error('Error loading 3D model:', error);\n     }\n   }\n\n   init();\n </script>\n</body>\n</html>\n\n<!-- <embed src=\"/html5/index.html\" width=\"1584px\" height=\"900px\"> -->","tags":["计算机","3D"]},{"title":"2023IMMC国际赛","url":"/2023/03/13/2023IMMC国际赛/","content":"# 2023IMMC国际赛\n\n[https://github.com/tioibiy/IMMC](`Github仓库`)\n\n## 思路\n\n~~还是喜欢规划题~~\n\n我觉得这次整体模型上思路问题不大，微分方程模拟是一个可行的解决方案\n\n问题在于细节上\n\n1. 归一化处理不够完全，应该先将所有数据整体归一，比如将坡度的数值换算成$[0,1]$中的一个“分值”、将人口换算成环境承载能力百分比等等\n2. 没有重视数据量纲的处理~~就是归一化没做好喳~~，导致对不同环境有不同依赖的设施，在微分方程模拟中产生的解有极大的差异\n3. 没有重视模型的深度。我们需要向评委展示我们模型思维的能力，需要使用多层嵌套、横向对比、多角度验证过的模型\n4. 重视数学公式的推导和验证，给组员讲明白符号定义和注释\n\n## 过程\n\n1. 这5天有相当长的一部分时间在摸鱼 ~~大抵是没有思路的迷茫罢~~\n2. 下次自己写个时间表，提醒还有什么事情没完成，顺便记录突发的灵感\n3. 需要更长的时间进行软件的磨合\n4. 奶茶——\n5. 尽量让每个组员都有事做，不要在某个问题上死磕导致进度拖慢\n6. 组织大家一起想思路，头脑风暴，让每个人都参与模型的制定中；组织一个大家聚在一起改论文的时间\n7. 把自己脑海中想到的东西，尤其是数据的呈现方式、图表等画在白板上\n8. 找个好用的在线协作罢\n9. $pound15$便士\n\n## 程序\n\n1. 用git做程序版本控制 在有重大改动的时候（速度优化，增加基础功能，更改数据，重构）需要分出分支\n2. 一定 一定 一定 要编测试点 尤其是在最终版本确定之后 一定要编一个覆盖所有功能的大测试点，手写多轮循环后的结果\n3. 在写程序之前要确认思路 预判程序在展示数据上的输出 防止爆零或单一输出\n4. 做好注释 和队友有良好的沟通 写好文档 给大家讲懂\n5. 随时监控论文状态 把想到的想法记到时间表上以免忘记\n6. 降低数据重要性\n7. 提前想好量纲和归一化\n8. 想好了再打日志，打完日志要给日志写注释\n9. 巨大数据量的时候，写好 `Python`后要想想 `C++`的写法 算好时间复杂度，`Python`是 `C++`的$30$到$40$倍\n10. `Mathematica`是个天坑\n11. `Python`是个天坑\n12. 有时间写一个 `C++`数学库，包括有序数对、科学计数法、解微分方程和张量\n13. 用同样的系统做在线协作\n14. 用$Chatgpt$修改程序并优化和写注释\n15. 好好画图\n","tags":["计算机","IMMC","数学"]},{"title":"使用Mathematica对化学反应平衡进行模拟","url":"/2023/02/08/使用Mathematica对化学反应平衡进行模拟/","content":"\n# 使用Mathematica对化学反应平衡进行模拟\n\n## 反应平衡动力模拟\n\n对于任何一个溶液中发生的基元可逆反应可以用以下方式表示\n\n```mermaid\ngraph LR\n    A[反应物] --k1--> B\n    B[生成物] --k2--> A\n```\n\n$k_1$和$k_2$是此反应的反应速率常数\n\n反应方程式可表示为\n\n$$\nA\\leftrightharpoons B\\quad K=\\frac{k_1}{k_2}\n$$\n\n或者也可以写成下面这样（我瞎编的）\n\n$$\nA\\stackrel{k_2}{\\underset{k_1}{\\leftrightharpoons}} B\n$$\n\n由此可以写出物质$A$和$B$的浓度关于时间$t$的微分方程\n\n$$\n\\begin{cases}\n    \\frac{dA}{dt}=-k_1A+k_2B\\\\\n    \\frac{dB}{dt}=+k_1A-k_2B\n\\end{cases}\n$$\n\n再翻译翻译就是\n\n$$\n\\begin{cases}\n    A'(t)=-k_1A(t)+k_2B(t) \\\\\n    B'(t)=+k_1A(t)-k_2B(t)\n\\end{cases}\n$$\n\n如果反应的反应物或生成物有多个物质或化学计量数不为$1$，则需要带入物质浓度的幂\n\n$$\na_1A_1+a_2A_2+\\cdots+a_nA_n\\stackrel{k_2}{\\underset{k_1}{\\leftrightharpoons}}b_1B_1+b_2B_2+\\cdots+b_mB_m\n$$\n\n$$\n\\begin{cases}\n    \\frac{dA_i}{dt}=-k_1\\prod_{u=1}^nA_u^{a_u}+k_2\\prod_{v=1}^mB_v^{b_v} \\\\\n    \\frac{dB_j}{dt}=+k_1\\prod_{u=1}^nA_u^{a_u}-k_2\\prod_{v=1}^mB_v^{b_v}\n\\end{cases}\\\\\n\\begin{cases}\n    A_i'(t)=-k_1\\prod_{u=1}^nA_u^{a_u}(t)+k_2\\prod_{v=1}^mB_v^{b_v}(t) \\\\\n    B_j'(t)=+k_1\\prod_{u=1}^nA_u^{a_u}(t)-k_2\\prod_{v=1}^mB_v^{b_v}(t)\n\\end{cases}\n$$\n\n## `Mathematica`!\n\n[看我博客的白嫖教程！](https://tioibiy.github.io/2023/02/02/%E5%85%8D%E8%B4%B9%E7%9A%84Wolfram-Engine%E5%AE%9E%E7%8E%B0Mathematica/)\n\n完整程序会放在最后\n\n首先我们需要一个`Mathematica`\n\n其次需要一些用来测试的化学反应\n\n这里以碳酸的电离平衡为例\n\n$$\n\\scriptsize\n\\begin{matrix}\n    \\mathrm{CO_2}+&\\mathrm{H_2O}&\\stackrel{k_{12}}{\\underset{k_{11}}{\\leftrightharpoons}}&\\mathrm{H_2CO_3}&&&&&&&\\quad K=\\frac{k_{11}}{k_{12}}=&\\frac{1}{600}&& \\\\\n    &&&\\mathrm{H_2CO_3}&\\stackrel{k_{22}}{\\underset{k_{21}}{\\leftrightharpoons}}&\\mathrm{HCO_3^-}&&+&\\mathrm{H^+}&&\\quad K=\\frac{k_{21}}{k_{22}}=&4.3&\\cdot&10^{-7} \\\\\n    &&&&&\\mathrm{HCO_3^-}&\\stackrel{k_{32}}{\\underset{k_{31}}{\\leftrightharpoons}}\\mathrm{CO_3^{2-}}&+&\\mathrm{H^+}&&\\quad K=\\frac{k_{31}}{k_{32}}=&5.6&\\cdot&10^{-11} \\\\\n    &\\mathrm{H_2O}&\\stackrel{k_{42}}{\\underset{k_{41}}{\\leftrightharpoons}}&&&&&&\\mathrm{H^+}&+\\mathrm{OH^-}&\\quad K=\\frac{k_{41}}{k_{42}}=&&&10^{-14}&=K_w\n\\end{matrix}\n$$\n\n### 初始化\n\n首先，为了避免奇奇怪怪的$\\mathfrak{BUG}$，先清除全局变量\n\n```wl\nClear[\"Global`*\"]\n```\n\n其次需要声明方程的反应速率常数\n\n```wl\nb=5;\nk11=4.3 *   10^(-3.5 +b);\nk12=1   *   10^(+3.5 +b);\nk21=5.6 *   10^(-5.5 +b);\nk22=1   *   10^(+5.5 +b);\nk31=1   *   10^(-0     );\nk32=1   *   10^(+14    );\nk41=1   *   10^(     +0);\nk42=600 *   10^(     +0);\nT=10;\n```\n\n`T`是时间上限，即微分方程自变量的最大值\n\n其中$k_{ij}$值与化学方程式中的$k_{ij}$有些许不同和错位，亿些细节放到最后再解释\n\n接着就可以开始解微分方程了~\n\n### 微分方程！\n\n```wl\n{H2CO3,H,OH,HCO3,CO3,CO2}=NDSolveValue[{\n\n    H2CO3'[t]   ==  -k11*H2CO3[t]+k12*H[t]*HCO3[t]                                                      +k41*CO2[t]-k42*H2CO3[t]    ,\n    HCO3'[t]    ==  +k11*H2CO3[t]-k12*H[t]*HCO3[t]  -k21*HCO3[t]+k22*H[t]*CO3[t]                                                    ,\n    CO3'[t]     ==                                  +k21*HCO3[t]-k22*H[t]*CO3[t]                                                    ,\n    H'[t]       ==  +k11*H2CO3[t]-k12*H[t]*HCO3[t]  +k21*HCO3[t]-k22*H[t]*CO3[t]    +k31-k32*H[t]*OH[t]                             , \n    OH'[t]      ==                                                                  +k31-k32*H[t]*OH[t]                             ,\n    CO2'[t]     ==                                                                                      -k41*CO2[t]+k42*H2CO3[t]    ,\n\n    H2CO3[0]    ==  0       ,\n    H[0]        ==  10^(-7) ,\n    OH[0]       ==  10^(-7),\n    HCO3[0]     ==  0       ,\n    CO3[0]      ==  0.01    ,\n    CO2[0]      ==  0\n\n},{H2CO3,H,OH,HCO3,CO3,CO2},{t,0,T}];\n```\n\n``NDSolveValue[微分方程列表,所求因变量列表,{自变量,自变量最小值,自变量最大值}]``，返回数值解的列表，其元素为所求因变量与自变量的数值关系（大概）\n\n### 可视化\n\n```wl\nPlot[{H2CO3[t]},{t,0,T},PlotLegends -> \"Expressions\"];\nPlot[{HCO3[t]},{t,0,T},PlotLegends -> \"Expressions\"];\nPlot[{CO3[t]},{t,0,T},PlotLegends -> \"Expressions\"];\nPlot[{{H2CO3[t]},HCO3[t],CO3[t]},{t,0,T},PlotLegends -> \"Expressions\"]\nPlot[{pH[t]=-Log10[H[t]],pOH[t]  =-Log10[OH[t]]},{t,0,T}, PlotLegends -> \"Expressions\",PlotRange -> {0, 14}] \nPlot[{H[t]*HCO3[t]/H2CO3[t] ,K1[t]=k11/k12},{t,0,T}, PlotLegends -> \"Expressions\"]\nPlot[{H[t]*CO3[t]/HCO3[t]   ,K2[t]=k21/k22},{t,0,T}, PlotLegends -> \"Expressions\"]\nPlot[{H[t]*OH[t]            ,K3[t]=k31/k32},{t,0,T}, PlotLegends -> \"Expressions\"]\n```\n\n``Plot[因变量列表,{自变量,自变量最小值,自变量最大值},其他参数]``，返回绘制的折线图。其他参数中`PlotLegends -> \"Expressions\"`可显示图例（`Plot[]`中只绘制一个因变量时无作用）\n\n以上代码绘制了$\\mathrm{H_2CO_3}$，$\\mathrm{HCO_3^-}$，$\\mathrm{CO_3^{2-}}$，$\\mathrm{H^+}$，$\\mathrm{OH^-}$，$p\\mathrm{H}$，$p\\mathrm{OH}$以及三个可逆反应的$Q-K$关系\n\n## $\\mathfrak{BUG}$\n\n1. 必须要加``Clear[\"Global`*\"]``，否则会出现无法预料的$\\mathfrak{BUG}$\n2. $K=\\frac{k_1}{k_2}$，但对$k_1$和$k_2$本身的大小并没有要求，即每一组符合条件的$k_1,k_2$都可以用于表示同一个方程。对于多个反应，改变其中几个反应的$k_1,k_2$（保证$k_1,k_2$的比值$K$不变），反应达到平衡时各组分浓度不会发生改变，但平衡前各组分浓度变化的过程会发生改变。但$|k_1|$，$|k_2|$越大，方程越快达到平衡。\n3. 程序中所有$k_{ij}$是经过调试找到的能较快达到平衡且较“好看”的组合。增加了一个参数`b`以更好控制$k$的数量级。这可能并不符合实际反应原理，但有利于调试\n4. 加入$\\mathrm{H_2O}\\stackrel{k_{42}}{\\underset{k_{41}}{\\leftrightharpoons}}\\mathrm{H^+}+\\mathrm{OH^-}$且画出$p\\mathrm{H},p\\mathrm{OH}$后出现了$p\\mathrm{H}+p\\mathrm{OH}\\neq 14$的情况。需要将$k_{41},k_{42}$增大使得此反应更快平衡（或增大反应时间`T`也能看到效果）这里调整到$k_{41}=1,k_{42}=10^{14}$，若再调高则超出了`Mathematica`的`int`范围（¿）\n5. 测试中各组分浓度初值尽量不超过$1(mol/L)$（我猜是这个单位？），否则可能出现不论如何调整$k$和`T`也没有反应的情况，原因不明，我猜是因为水解平衡反应不过来了\n6. 测试中组分浓度越低，效果越好，这大概就是越稀越水解吧\n7. `T`较大时可视化的图表中的图线会出现抽风的情况，我猜是因为每次$dt$采样的间隔较大的原因\n8. 如果认为$\\mathrm{CO_2}$生成后立即溢出，即视$c(\\mathrm{CO_2})$在任何时间均为常数，则$\\mathrm{CO_3^{2-}}$在酸性环境下生成$\\mathrm{CO_2}\\uparrow$的反应可视化效果较好\n\n## 完整程序\n\n```wl\nClear[\"Global`*\"]\nb=5;\nk11=4.3 *   10^(-3.5 +b);\nk12=1   *   10^(+3.5 +b);\nk21=5.6 *   10^(-5.5 +b);\nk22=1   *   10^(+5.5 +b);\nk31=1   *   10^(-0     );\nk32=1   *   10^(+14    );\nk41=1   *   10^(     +0);\nk42=600 *   10^(     +0);\nT=10;\n\n{H2CO3,H,OH,HCO3,CO3,CO2}=NDSolveValue[{\n\n    H2CO3'[t]   ==  -k11*H2CO3[t]+k12*H[t]*HCO3[t]                                                      +k41*CO2[t]-k42*H2CO3[t]    ,\n    HCO3'[t]    ==  +k11*H2CO3[t]-k12*H[t]*HCO3[t]  -k21*HCO3[t]+k22*H[t]*CO3[t]                                                    ,\n    CO3'[t]     ==                                  +k21*HCO3[t]-k22*H[t]*CO3[t]                                                    ,\n    H'[t]       ==  +k11*H2CO3[t]-k12*H[t]*HCO3[t]  +k21*HCO3[t]-k22*H[t]*CO3[t]    +k31-k32*H[t]*OH[t]                             , \n    OH'[t]      ==                                                                  +k31-k32*H[t]*OH[t]                             ,\n    CO2'[t]     ==                                                                                      -k41*CO2[t]+k42*H2CO3[t]    ,\n\n    H2CO3[0]    ==  0       ,\n    H[0]        ==  10^(-7) ,\n    OH[0]       ==  10^(-7),\n    HCO3[0]     ==  0       ,\n    CO3[0]      ==  0.01    ,\n    CO2[0]      ==  0\n\n},{H2CO3,H,OH,HCO3,CO3,CO2},{t,0,T}];\n\nPlot[{H2CO3[t]},{t,0,T},PlotLegends -> \"Expressions\"];\nPlot[{HCO3[t]},{t,0,T},PlotLegends -> \"Expressions\"];\nPlot[{CO3[t]},{t,0,T},PlotLegends -> \"Expressions\"];\nPlot[{{H2CO3[t]},HCO3[t],CO3[t]},{t,0,T},PlotLegends -> \"Expressions\"]\nPlot[{pH[t]=-Log10[H[t]],pOH[t]  =-Log10[OH[t]]},{t,0,T}, PlotLegends -> \"Expressions\",PlotRange -> {0, 14}] \nPlot[{H[t]*HCO3[t]/H2CO3[t] ,K1[t]=k11/k12},{t,0,T}, PlotLegends -> \"Expressions\"]\nPlot[{H[t]*CO3[t]/HCO3[t]   ,K2[t]=k21/k22},{t,0,T}, PlotLegends -> \"Expressions\"]\nPlot[{H[t]*OH[t]            ,K3[t]=k31/k32},{t,0,T}, PlotLegends -> \"Expressions\"]\n```\n\n## 测试输出\n\n![1675912940285](image/文档/1675912940285.png)\n\n![1675912960575](image/文档/1675912960575.png)\n\n![1675912981872](image/文档/1675912981872.png)\n\n![1675913031329](image/文档/1675913031329.png)","tags":["计算机","化学"]},{"title":"免费的Wolfram Engine实现Mathematica","url":"/2023/02/02/免费的Wolfram-Engine实现Mathematica/","content":"\n# 免费的Wolfram Engine实现Mathematica\n\n[`Wolfram`官网](https://www.wolfram.com)\n\n## [下载`Wolfram Engine`](https://www.wolfram.com/engine/?source=nav)\n\n下载完成后还需在官网完成账号注册和免费`Wolfram Engine`许可证的[注册](https://account.wolfram.com/access/wolfram-engine/free)\n\n具体细节见[官网手册](https://support.wolfram.com/46069)\n\n## [下载`Wolfram Player`](https://www.wolfram.com/player/?source=nav)\n\n一路回车安装\n\n完成后需要将`WolframPlayer.exe`所在的路径添加至环境变量，我添加的路径是```C:\\Program Files\\Wolfram Research\\Wolfram Player\\13.2```\n\n## 配置`Visual Studio Code`\n\n1. 首先，你需要一个[`VScode`](https://code.visualstudio.com/Download#)\n2. 下载`Vscode`中的[`Wolfram Language Notebook`插件](https://marketplace.visualstudio.com/items?itemName=njpipeorgan.wolfram-language-notebook)\n\n这时新建一个`*.wlnb`的测试文件，就可以测试扩展和`Wolfram Engine`是否可用了\n\n### 扩展设置：\n\n建议勾选：\n\n- [x] `Wolfram Language Notebook › Rendering: Image With Transparency`\n\n在没有使用`Wolfram Player`时渲染图片可以剔除背景\n\n## 接入`Wolfram Player`\n\n[参考链接](https://zhuanlan.zhihu.com/p/478292678)\n\n找到文件夹`C:\\Users\\username\\AppData\\Roaming\\WolframEngine\\Kernel`，文件夹中有一个名为`init.m`的文件，将其打开并在结尾添加以下代码\n\n```\nBeginPackage[\"CommandLineUtilities`Display`\"];\n\nWolframPlayer;\n\nBegin[\"`Private`\"];\n\n$TemporaryOutput = FileNameJoin@{$TemporaryDirectory, \"WolframKernelOutput\"};\nIf[!DirectoryQ@#, CreateDirectory@#] &@$TemporaryOutput;\nWriteToShell[str_] := (\n\tIf[Head@$ShellProcess =!= ProcessObject, $ShellProcess = StartProcess@$SystemShell];\n\tWriteLine[$ShellProcess, str];\n\tstr\n)\n\nMakeNotebook[box_] := Notebook[{Cell@BoxData@box}, WindowSize -> All]\n\nWolframPlayer[expr_, box_] := (\n\t$WolframPlayerProcess = If[# === {}, StartProcess@\"WolframPlayer\", None] &@SystemProcesses@\"WolframPlayer\";\n\tStringJoin[\n\t\t\"WolframPlayer \",\n\t\tExport[FileNameJoin@{$TemporaryOutput, CreateUUID[\"CDFOutput-\"]<>\".cdf\"}, MakeNotebook@box, \"CDF\"]\n\t] //WriteToShell;\n\tExportString[OutputForm@expr, \"Text\"]\n)\n\n$Epilog := (\n\tKillProcess/@{$ShellProcess, $WolframPlayerProcess};\n\tQuiet@DeleteFile@FileNames[__, $TemporaryOutput];\n\tIf[FindFile[\"end`\"] =!= $Failed, << \"end`\"] (* Original definition. You can read it with OwnValues. *)\n)\n\nEnd[];\n\nEndPackage[];\n\n(*$DisplayFunction = WolframPlayer[#, ToBoxes@#]&;*)\n$Post = With[{box = ToBoxes@#},\n\tIf[FreeQ[DynamicBox|DynamicModuleBox|GraphicsBox|Graphics3DBox]@box,\n\t\t\t#,\n\t\t\tWolframPlayer[#, box]\n\t]\n]&;\n```\n\n保存并退出\n\n{% note danger %}\n\n`Wolfram Player`在渲染`Manipulate`函数时可能引起排版错误导致滑动条不可见\n\n解决办法：在`Wolfram Player`弹出的图像窗口中选择`窗口（W）`->`重排窗口`->`水平平铺窗口（H）`可大概率解决\n\n{% endnote %}","tags":["计算机"],"categories":["完成"]},{"title":"微积分的力量！","url":"/2023/01/19/微积分的力量！/","content":"\n# 微积分的力量！\n\n读完过了好久才下决心来写这个读后感……\n\n原因是没什么可写的😢\n\n## 阿基米德的抛物线求积法\n\n### 题设：\n\n<iframe scrolling=\"no\" title=\"抛物线求积_题设\" src=\"https://www.geogebra.org/material/iframe/id/qk745znr/width/1369/height/604/border/888888/sfsb/true/smb/false/stb/false/stbh/false/ai/false/asb/false/sri/false/rc/false/ld/false/sdz/false/ctl/false\" width=\"1080px\" height=\"360px\" style=\"border:0px;\"> </iframe>\n\n已知一抛物线与其上一条割线，求抛物线与之围成图形的面积，即上图中浅蓝色部分，这个图形也被称作抛物线弓形\n\n<iframe scrolling=\"no\" title=\"抛物线求积_题设_2\" src=\"https://www.geogebra.org/material/iframe/id/b9uk45rr/width/2464/height/1138/border/888888/sfsb/true/smb/false/stb/false/stbh/false/ai/false/asb/false/sri/false/rc/false/ld/false/sdz/true/ctl/false\" width=\"1080px\" height=\"360px\" style=\"border:0px;\"> </iframe>\n\n更具体的：\n\n**已知：**\n\n<center>\n\n对任意抛物线$f$与其割线$AB$，作直线$h\\parallel AB$且与抛物线相切，即\n\n$$\nf(x)=x^2\\\\\n\\forall A,B\\in f,A\\neq B,h\\parallel AB,h\\cap f=\\{C\\}\n$$\n\n</center>\n\n**求证：**\n\n<center>\n\n抛物线弓形的面积为$\\triangle ABC$面积的$\\frac{4}{3}$\n\n若将抛物线弓形记作$a$，即求证\n\n$$\nS_a=\\frac{4}{3}S_{\\triangle ABC}\n$$\n\n</center>\n\n### 证：\n\n","tags":["读后感！"]},{"title":"对世界的理解增加了","url":"/2022/12/29/对世界的理解增加了/","content":"\n# 对世界的理解增加了\n\n## 数学\n\n### 微积分\n\n[微积分——3Blue1Brown](https://www.bilibili.com/video/BV1qW411N7FU)\n\n[洛必达——知乎](https://www.zhihu.com/question/28862411/answer/123019423?)\n\n## 物理\n\n[物理原理——知乎](https://zhuanlan.zhihu.com/p/452418979)\n\n[大物学习笔记](https://zhuanlan.zhihu.com/p/139082395)\n\n### 天体\n\n[万有引力形成的椭圆轨道——3Blue1Brown](https://www.bilibili.com/video/BV1Zs411A7KJ)\n\n### 电磁学\n\n#### 电场与磁场\n\n[静电场与导体的高斯定理——知乎](https://zhuanlan.zhihu.com/p/86750794)\n\n[矢量场的散度和旋度——3Blue1Brown](https://www.bilibili.com/video/BV19s41157Z4/?)\n\n[麦克斯韦方程组（积分篇）——知乎](https://zhuanlan.zhihu.com/p/71793554)\n\n[麦克斯韦方程组（微分篇）——知乎](https://zhuanlan.zhihu.com/p/78503083)\n\n#### 电路\n\n[如何理解电动机的非纯电阻电路——知乎](https://zhuanlan.zhihu.com/p/111371667)\n\n[等效电源——知乎](https://zhuanlan.zhihu.com/p/402442227)\n\n### 量子力学\n\n[不确定性原理](https://www.bilibili.com/video/BV1WW411x7BJ?)\n\n## 化学\n\n[杂化轨道的数学解释](https://www.bilibili.com/video/BV1Tg4y1n79X)\n\n## 计算机\n\n### 人工智能\n\n[卷积——3Blue2Brown](https://www.bilibili.com/video/BV1Vd4y1e7pj?)\n\n[反向传播——3Blue2Brown](https://www.bilibili.com/video/BV16x411V7Qg?)\n","tags":["生活&吐槽"],"categories":["更新中"]},{"title":"qqgg","url":"/2022/12/08/qqgg/","content":"\n# qqgg的东西增加了\n\n1. 为什么物理中量纲不同不能运算，比如，我们不能将面积$(m^2)$加上一个距离$(m)$。可是数学中却可以写出不齐次的多项式，比如$ax^2+bx+c$，或者$\\sum_{i=0}a_ix^i$。如果硬是将$2m^2$加上$1m$，写作$2m^2+1m$，确实可以这么写，但是几乎无法找到现实中对应的物理量。即使物理中存在的二次函数，如匀速直线运动中位移随初速度和时间的变化：$\\vec{x}=\\vec{v_0}t+\\frac{1}{2}\\vec{a}t^2$，它的量纲也是正确的，因为$\\vec{x},\\vec{v_0},\\vec{a}$的量纲不同，“恰好”互相抵消。可是我们却不能赋予数学中不同次项系数$a_i$以不同的量纲……\\\n不过这或许就是为什么要将角度转化为弧度的一种解释了吧，毕竟弧度没有单位，而数学不需要单位\\\n{% note info %}\n或许可以写成\n\n$\\begin{pmatrix}\n    2 \\\\\n    1\n\\end{pmatrix}\n\\begin{pmatrix}\n    m^2 \\\\\n    m\n\\end{pmatrix}$\n\n甚至可以定义他们的运算\n\n$\\begin{pmatrix}\n    2 \\\\\n    1\n\\end{pmatrix}\n\\begin{pmatrix}\n    m^2 \\\\\n    m\n\\end{pmatrix}\n+\n\\begin{pmatrix}\n    3 \\\\\n    5\n\\end{pmatrix}\n\\begin{pmatrix}\n    m^2 \\\\\n    m\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n    5 \\\\\n    6\n\\end{pmatrix}\n\\begin{pmatrix}\n    m^2 \\\\\n    m\n\\end{pmatrix}$\n\n{% endnote %}\n\n2. 植食性昆虫和植物抗虫反应是他们共同进化的结果\\\n{% note info %}\n\n如：植物遭到昆虫蚕食后会分泌茉莉酸，启动抗虫反应，分泌杀虫物质，产生吸引昆虫天敌的挥发物；而烟粉<ruby>虱<rt>shī</rt></ruby>则能合成$Bt56$蛋白，随烟粉虱唾液进入植物，抑制茉莉酸启动的抗虫反应\n\n{% endnote %}\n那么，如果放任地球上的生命如此“共同进化”，会不会导致生物之间耦合过多，愈发臃肿，各个物种之间尔虞我诈，关系层层叠叠，导致地球上的生物作为一个整体，更加不适应宇宙这个大环境？\\\n就像是神经网络过拟合一样，在训练集上表现很好，但是无法泛化到更加复杂的系统中\n\n3. 积分是对极小值求和\n$$\n\\begin{aligned}\n\\int_{l}^{r}f(x)dx\n=&\\lim_{n \\to \\infty}\\sum_{i=1}^{n}\\frac{r-l}{n}f\\left((1-\\frac{i}{n})l+\\frac{i}{n}r\\right)\\\\\n=&\\lim_{n \\to \\infty}\\frac{r-l}{n}\\sum_{i=1}^{n}f\\left((1-\\frac{i}{n})l+\\frac{i}{n}r\\right)\n\\end{aligned}\n$$\n那能不能定义极小值的积？\n$$\n\\begin{aligned}\nP_{l}^{r}f(x)dx\n=&\\lim_{n \\to \\infty}\\prod_{i=1}^{n}\\frac{r-l}{n}f\\left((1-\\frac{i}{n})l+\\frac{i}{n}r\\right)\\\\\n=&\\lim_{n \\to \\infty}\\left(\\frac{r-l}{n}\n\\right)^n\\prod_{i=1}^{n}f\\left((1-\\frac{i}{n})l+\\frac{i}{n}r\\right)\n\\end{aligned}\n$$\n不过没什么实际意义\n4. {%cq%}\n随机变换符号的位置是有效的简化手段\\\n也是构建人脑无法处理的复杂论证过程的简便方式\\\n——《微积分的力量》\n{%endcq%}\n生动形象，就像傅里叶变换和小奥解方程一样\\\n傅里叶变换使我们可以从另一种角度看待和运算函数，同时不丢失函数所携带的信息；\\\n在我们最初理解“方程”的时候会用“天平”来形容它：两边同时加上相同的量，或将天平两边的量同时翻倍，天平仍然平衡\\\n他们都通过“简单”的符号变换，在人脑能理解的证明过程抽提出“定理”，以期解决复杂的问题\\\n解方程时不一定需要思考“两边同时增加或减少$(2x+3)$，等式仍然成立”，而是将他作为一个烂熟于心的定理来使用，这样才能用人脑仍能理解的方法解决更复杂的问题","tags":["生活&吐槽"],"categories":["更新中"]},{"title":"IMMC?","url":"/2022/11/30/IMMC/","content":"\n# $IM^2C$\n\n{%cq%}\n$$\n\\begin{align*}\n数学剑魔\n\\end{align*}\n$$\n{%endcq%}\n\n## 题目链接\n\n[2023中华赛A题(秋季赛)](http://istem.info/ueditor/php/upload/file/20221117/1668686658777052.pdf)\n\n[2023中华赛B题(秋季赛)](http://istem.info/ueditor/php/upload/file/20221117/1668697147832368.pdf)\n\n[2023中华赛C题(秋季赛),初中组专用 ~~涝~~](http://istem.info/ueditor/php/upload/file/20221117/1668686848234409.pdf)\n\n# $Day_0$\n\n晚上8:00开腾讯会议发题\n\n高中组只有$A$ $B$两道可选\n\n{% tabs tab1,1%}\n\n<!-- tab A -->\n\n**第一题**\n\n初印象觉得是$Floyd$加搜索或者$dp$\n\n但是仔细一看发现不对，如果真搜索那复杂度$\\omicron(m^n)\\approx 9^{32}$\n\n如果以计算机$10^9/s$的计算速度粗略估计，那么需要约$1.0888139967949368\\times10^{12}$个世纪才能完成……\n\n叶老师发了个针对第一题图论的材料，~~还好我看了看~~，对后续旅行商的思路有一定的启发\n\n这个时候$rc$发现第二问还书量很少，认为不用纠结，事实证明这很有远见\n\n一晚上都在想怎么做第一题正解……\n\n<!-- endtab -->\n\n<!-- tab B -->\n\n**第二题**\n\n纯纯的搜资料题\n\n题面里“最近公共祖先”倒是给我兴奋了一把，可惜根本用不到\n\n~~用不到那你出题人为什么要写它~~\n\n第一问超级简单，$rc$人型计算器加$Excel$十分钟搞定，拟合度$98.58\\%$\n\n![第二题拟合](https://raw.githubusercontent.com/tioibiy/image/master/image/8659a80174a1b7878b2a668e158ab1a.png)\n\n不过我们觉得作为第一问显然不可能这么简单，肯定是我们有什么没有考虑到的\n\n~~事实证明第一问就是这么简单~~\n\n$Cyk$和$Hyd$分工看文献\n\n<!-- endtab -->\n\n{% endtabs %}\n\n\n# $Day_1$\n\n早上起来突然想到$A$题好像能判环+“小范围”枚举+差分约束，不过在$Day_3$的时候被我发现这个方法有大问题（悲\n\n{% note warning %}\n其实就是学差分约束太久忘记形式了……$\\sum_i x_i\\le b$并不构成差分系统，$x_i-x_j\\le b$才是\n{% endnote %}\n\n之后去$cyk$那里（感谢$rc\\&Cyk$！\n\n在车上被老师催，决定做$A$题\n\n$rc$他爸建议手动**决策树**先求个**模糊解**\n\n{% note success %}\n模糊解这个提醒确实把我从坑里拉出来了，并且很大程度上影响了我后续的思路，毕竟这玩意确实很难做到精确\n{% endnote %}\n\n某场外援助说看着像状压$dp$并且再次提醒我这好像**不是**一道$Oi$题（正确的，感谢$Zzy$！\n\n到了$cyk$那里之后开始讨论具体实施\n\n这里我也不知道该怎么做了，只能走一步是一步\n\n8:00叶老师的破题，不能说是意义重大，也可以称得上是毫无卵用了\n\n甚至连$Dijkstra$和$Floyd$的时间复杂度都讲反了\n\n$$\n\\begin{align*}\nDijkstra&:O(n\\log{n})\\\\\nFloyd&:O(n^3)\n\\end{align*}\n$$\n\n{% note danger %}\n中间顺便上了堂化学课，四个人没一个听的，$Wcy$甚至点名提问\n{% endnote %}\n\n$rc$开始做源数据的格式化，$Cyk$人型计算器先搞出了个第一问可行解，总路程$90$多公里，总时间$5$个多小时\n\n事实证明，这个可行解已经十分优化\n\n~~甚至比某组的蚁群算法的结果更加优化~~\n\n![$Cyknb!$](https://raw.githubusercontent.com/tioibiy/image/master/image/cee69fb77ee572ce2f3876685584c35.jpg)\n\n漫无目的逛百度的时候发现了$vrp$和$cvrp$，$cvrp$问题的描述和题面高度相似，思路开始转向\n\n其实这个时候已经查到``ortools``这个库了，但由于想法上还是局限于精确解，并且$CSDN$上的博文质量实在不敢恭维，导致我并没有深挖\n\n中午吃完~~必胜客！~~饭把思路捋了捋并决定用遗传算法解决$cvrp$\n\n```mermaid\nflowchart LR\n源数据 --Floyd--> 多源最短路\n多源最短路 --拆点法--> 以书本为节点的全连接无向图\n以书本为节点的全连接无向图 -.节点一次性.-> 路线规划\n以书本为节点的全连接无向图 --cvrp--> 路线规划\n源数据 -.连接成环.-> 路线规划\n路线规划 --递归枚举--> 结论\n```\n\n开始写$Floyd$和拆点法，两个小时搞定\n\n之后就在找遗传算法现有的代码了，从``GitHub``上下了一个，经过漫长的调试，效果还没$Cyk$的可行解快，实在锂镤\n\n此时还没有想好怎么解决充电站单程的问题\n\n# $Day_2$\n\n早上起来思如泉涌，想到可以添加节点控制单向路径以解决充电桩\n\n到地方之后开始注意``ortools``\n\n途中省略``C++``和``Python``环境调试……\n\n{% note warning %}\n``C++``调不出来的原因竟是因为``ortools``不支持``Visual Studio Code``只支持``Visual Studio``\n{% endnote %}\n\n抄了个$CSDN$代码，效果拔群，第一问路径优化到$86.7km$\n\n写完递归枚举之后时间结论优化到了$4.86h$\n\n此时我还没意识到手打的辅助点$id$写错了\n\n直到晚上差不多把第一问答案搞出来了\n\n开始认真研究$rc$找的``ortools``官方[``api``](https://developers.google.cn/optimization)并发现了自己忽略的很多用法\n\n比如可以添加松弛条件，让机器人在某“多书”站点不取完所有书，也就不必写拆点算法了\n\n{% note danger %}\n$<0$有一种语言艺术的美\n{% endnote %}\n\n# $Day_3$\n\n早上想了个第二问处理充电桩的方法，但是早上和$Cyk$讨论发现了误区\n\n和叶老师开了个会，意识到第一问方案很可能可以直接运用到第二问中\n\n$Cyk$开始人工校验\n\n{%cq%}\n$$\n\\begin{align*}\n科技民工！&\\\\\n&——Hyd\n\\end{align*}\n$$\n{%endcq%}\n\n最终历经波折，第一问的结论真的可以用到第二问！\n\n{% note info %}\n其中需要把一组的路径规划反过来（环具有对称性）以确保不会超载\n{% endnote %}\n\n下午$Cyk$校对的时候发现我昨天辅助点的错误，好在第二天改完之后对第二问影响不大，路径长度甚至优化到了$86.5km,4.82h$\n\n# $Day_4$\n\n居家改论文\n\n实在折磨，$\\LaTeX$技术力过低，版本控制不力，总之……$Hyd,rcnb!$\n\n不过最终还是有很多纸面上的错误\n\n# 改进\n\n{% tabs tab2,1 %}\n\n<!-- tab 思路 -->\n\n完全不在我的控制范围之内\n\n每一天都出乎意料\n\n从精确解到模糊解\n\n从遗传迭代到引导式搜索\n\n也只是摸着石头过河\n\n下次再发题之后应该有一个更明确地思路，比如这道题就应该直接看出旅行商问题的本质，而不是固执地想精确解，毕竟这真的不是$Oi$题\n\n或许是阅历不足的原因罢\n\n<!-- endtab -->\n\n<!-- tab 技术 -->\n\n1. ``VS code Live Share``插件共同编辑$\\LaTeX$论文\n2. ``Git``版本控制，合并不同修改\n3. ``Python``，一定程度上能减少科技民工的工作量\n4. 尝试使用$\\LaTeX$画图，如果太难了那就试试矢量绘图软件吧，会好看一些\n\n一定要改，要不然会疯的\n\n<!-- endtab -->\n\n<!-- tab 合作 -->\n\n……没什么可改的\n\n为数不多体验很爽的小组合作任务\n\n<!-- endtab -->\n\n{% endtabs %}\n","tags":["计算机","IMMC","数学"],"categories":["完成"]},{"title":"超越无穷大！","url":"/2022/11/10/超越无穷大！/","content":"\n# 超越无穷大！\n\n## 其中的一些知识点\n\n### 基数\n\n我们称一个**集合**所包含的**元素数量**为这个集合的**基数**\n\n则集合$A$的基数可表示为$|A|$\n\n集合$A$与$B$**大小相等**的**充要条件**是$|A|=|B|$\n\n### 自然数集\n\n令$\\mathbb{N}$表示**自然数集**，$\\mathbb{N^+}$表示**正整数集**（也可以用$\\mathbb{N^*}$或$\\mathbb{W}$表示）\n\n则有\n\n$$\n0=\\varnothing =\\{\\}\\in \\mathbb{N}\n$$\n\n$$\n\\forall i\\in \\mathbb{N},i+1=\\{j|j<i, j\\in \\mathbb{N}\\}=\\{0, \\ldots ,i\\}\\in \\mathbb{N}\n$$\n\n$$\n\\mathbb{N^+}=\\{i|i\\in \\mathbb{N}, i\\neq 0\\}\n$$\n\n容易得出\n\n$$\n\\scriptsize\n\\begin{matrix}\n    0&&&&&&&\n    &=&&&&&&&\\varnothing\n    \\\\\n    1&\n    =\\{j|j<1, j\\in \\mathbb{N}\\}\n    =\\{&0&\\}&&&&\n    &=&&&&&&&\\{\\varnothing\\}&&\n    \\\\\n    2&\n    =\\{j|j<2, j\\in \\mathbb{N}\\}\n    =\\{&0&,&1&\\}&&\n    &=&&&&&&\\big\\{\\varnothing,&\\{\\varnothing\\}&\\big\\}&\n    \\\\\n    3&\n    =\\{j|j<3, j\\in \\mathbb{N}\\}\n    =\\{&0&,&1&,&2&\\}\n    &=&\\Big\\{&\\varnothing&,&\\{\\varnothing\\}&,&\\big\\{\\varnothing,&\\{\\varnothing\\}&\\big\\}&\\Big\\}\n    \\\\\n    \\cdots\n\\end{matrix}\n$$\n\n$$\n\\mathbb{N}=\n\\scriptsize\n\\left\\{\n    \\begin{matrix}\n        &&&&&&&\\varnothing&&&,&\\\\\n        & &&&& &&\\{\\varnothing\\}&&&,&\\\\\n        & &&&& &\\big\\{\\varnothing,&\\{\\varnothing\\}&\\big\\}&&,&\\\\\n        & \\Big\\{&\\varnothing&,&\\{\\varnothing\\}&,&\\big\\{\\varnothing,&\\{\\varnothing\\}&\\big\\}&\\Big\\}&,&\\\\\n        &&&&&&&\\cdots \n    \\end{matrix}\n\\right\\}\n$$\n\n### 无穷大\n\n在“**数值**”上，我们认为**自然数集**$\\mathbb{N}$的**基数**$|\\mathbb{N}|=\\infty=\\aleph_0$\n\n其中[$\\aleph_0$](#读作alepg)是**最小**的无穷大，也就是自然数集$\\mathbb{N}$的基数$\\infty$\n\n无穷大可以作为**基数**，也可以作为**序数**，但这并不影响上面的定义\n\n作为基数或是序数的区别在于，无穷在参与运算时遵守的运算规则不同\n\n可以把“基数”与“序数”看成是无穷运算的两种规则\n\n### 更“无穷”的无穷大\n\n$$\n\\forall i,j\\in\\mathbb{N}, j\\ge 2,\\aleph _{i+1}=j^{\\mathbb{\\aleph _i}} \\label{EQA}\n$$\n\n可以看到，$\\aleph _{i+1}$的值与$j$无关，即\n\n$$\n\\forall i,a,b\\in \\mathbb{N},a,b\\ge 2,a^{\\mathbb{\\aleph _i}}=b^{\\mathbb{\\aleph _i}}\n$$\n\n那么我们就会得到一个不符合“**直觉**”的结论：\n\n\n\n$$\n\\infty<2^\\infty=10^\\infty=10000000^\\infty=\\cdots\n$$\n\n很不幸，这是正确的\n\n我们不妨令$\\eqref{EQA}$式中的$j=2$\n\n则有\n\n$$\n\\newcommand\\iddots{\\mathinner{\n    \\kern1mu\\raise1pt{.}\n    \\kern2mu\\raise4pt{.}\n    \\kern2mu\\raise7pt{\\Rule{0pt}{7pt}{0pt}.}\n    \\kern1mu\n}}\n\\begin{matrix}\n    \\aleph _0&=&|\\mathbb{N}|\\\\\n    \\aleph _1&=&2^{\\aleph _0}&=&2^{|\\mathbb{N}|}\\\\\n    \\aleph _2&=&2^{\\aleph _1}&=&2^{2^{|\\mathbb{N}|}}\\\\\n    \\aleph _3&=&2^{\\aleph _2}&=&2^{2^{2^{|\\mathbb{N}|}}}\\\\\\\\\n    &&\\dots\\\\\n    \\aleph _{i+1}&=&2^{\\aleph _i}&=&{\\underbrace{2^{2^{2^{\\iddots^{2^{|\\mathbb{N}|}}}}}}_{(i+1)个2}}\n\\end{matrix}\n$$\n\n由此可以构造出\n\n$$\n\\forall i,j\\in \\mathbb{N}, i<j,\\aleph _i<\\aleph _j\n$$\n\n#### 小思考\n\n如果构造一棵拥有$\\infty$层的二叉树\n\n那么他将拥有$2^{\\infty+1}-1=2^\\infty$个节点\n\n使用广度优先搜索对其编号，则我们就构建了一个$\\infty$到$2^\\infty$的一一映射\n\n```mermaid\ngraph TD\n    A((1))-->B((2))\n    A((1))-->C((3))\n    B-->D((4))\n    B-->E((5))\n    C-->F((6))\n    C-->G((7))\n    \n```\n\n和$\\aleph _0<\\aleph _1$相悖\n\n那么问题出在哪了？\n","tags":["读后感！"]},{"title":"VScode-C-环境搭建-Matplotlibcpp库","url":"/2022/11/02/VScode-C-环境搭建-Matplotlibcpp库/","content":"\n# 下载\n\n[Github](https://github.com/lava/matplotlib-cpp)\n[GitCode](https://gitcode.net/mirrors/lava/matplotlib-cpp)\n\n> GitCode会快一点\n\n下载后随便放在一个无中文的<a id=\"info\">目录</a>下就可以\n\n解压后将其改名为`matplotlibcpp`\n\n# VScode环境搭建\n\n[参考CSDN](https://blog.csdn.net/weixin_43769166/article/details/118365416?spm=1001.2101.3001.6661.1&depth_1-utm_relevant_index=1)\n\n## `tasks.json`配置\n\n在`tasks.json`文件中的`tasks.args`内，\n\n`\"-g\",\"${file}\",`与`\"-o\",`之间依次添加如下路径\n\n{%note warning%}\n> 根据自己的实际路径进行配置。\n{%endnote%}\n\n1. \n    ```json\n    \"-I\",\n    \"C:/c++_libraries/matplotlibcpp\",  // matplotlibcpp.h路径\n    ```\n\n    此处<a id=\"info3\">matplotlibcpp.h路径</a>为前文解压`matplotlib`的<a href=\"#info\">目录</a>\n\n    > `C:/c++_libraries/`文件夹是我自己建的`C++`库文件夹\n\n2. \n    ```json\n    \"-I\",\n    \"C:/Users/linru/AppData/Local/Programs/Python/Python310/include\",  // Python.h路径\n    ```\n\n    此处<a id=\"info4\">`Python.h`路径</a>是<a inf=\"info1\">`Python`文件夹</a>下`include`文件夹的目录\n\n    我这里的`Python.h`路径为`C:/Users/linru/AppData/Local/Programs/Python/Python310/`\n\n3. \n    ```json\n    \"-I\",\n    \"C:/Users/linru/AppData/Local/Programs/Python/Python310/Lib/site-packages/numpy/core/include\",  // numpy/arrayobject.h路径\n    ```\n\n    此处<a id=\"info5\">`numpy/arrayobject.h`路径</a>为上文<a href=\"#info1\">`Python.h`路径</a>下`numpy`库`include`文件目录\n    \n    即<a href=\"#info1\">`Python.h`路径</a>+`Lib/site-packages/numpy/core/include`\n\n4. \n    ```json\n    \"-L\",\n    \"C:/Users/linru/AppData/Local/Programs/Python/Python310\",  // python37.dll的所在目录\n    ```\n\n    此处`python37.dll`所在目录，即<a href=\"#info1\">`Python.h`路径</a>\n\n5. \n    ```json\n    \"-l\", \"python310\",  // python37.dll动态库\n    ```\n\n    此处`python37.dll`动态库，即`python`+`Python版本号`\n\n    这里的版本是`3.10`，即`python310`\n\n## `c_cpp_properties`配置\n\n在`c_cpp_properties`文件中的`configurations.includePath`内，依次增加如下路径\n\n1. \n    ```json\n    \"C:/c++_libraries/matplotlibcpp\",  // matplotlibcpp.h路径\n    ```\n\n    即上文的<a href=\"#info3\">`matplotlibcpp.h`路径</a>，也就是前文解压`matplotlib`的<a href=\"#info\">目录</a>\n\n2. \n    ```json\n    \"C:/Users/linru/AppData/Local/Programs/Python/Python310/include\",  // Python.h路径\n    ```\n    \n    即上文的<a href=\"#info4\">`Python.h`路径</a>\n\n3. \n    ```json\n    \"C:/Users/linru/AppData/Local/Programs/Python/Python310/Lib/site-packages/numpy/core/include\"  // numpy/arrayobject.h路径\n    ```\n\n    即上文的<a href=\"#info5\">`numpy/arrayobject.h`路径</a>\n\n> 需要重启`VScode`自动补全才能生效\n\n## 注释掉`matplotlibcpp.h`中两行代码\n\n找到解压`matplotlib`的<a href=\"#info\">目录</a>下的`matplotlibcpp.h`文件并打开\n\n将第`354`行\n\n```cpp\ntemplate <> struct select_npy_type<long long> { const static NPY_TYPES type = NPY_INT64; };\n```\n\n和第`356`行\n\n```cpp\ntemplate <> struct select_npy_type<unsigned long long> { const static NPY_TYPES type = NPY_UINT64; };\n```\n\n重复定义的两行<kbd>Ctrl</kbd>+<kbd>/</kbd>注释掉\n\n即将第`354`行改为\n\n```cpp\n// template <> struct select_npy_type<long long> { const static NPY_TYPES type = NPY_INT64; };\n```\n\n将第`354`行改为\n\n```cpp\n// template <> struct select_npy_type<unsigned long long> { const static NPY_TYPES type = NPY_UINT64; };\n```\n\n<kbd>Ctrl</kbd>+<kbd>s</kbd>保存\n\n## 测试\n\n测试代码\n\n```cpp\n#include \"matplotlibcpp.h\"\nnamespace plt = matplotlibcpp;\nint main() {\n    plt::plot({1,3,2,4});\n    plt::show();\n}\n```\n\n运行结果\n\n![运行结果](../img/VScode-C-环境搭建-Matplotlibcpp库-运行结果.png)","tags":["计算机"],"categories":["完成"]},{"title":"VScode C++环境搭建","url":"/2022/10/03/VScode-C-环境搭建/","content":"# [VS Code](https://code.visualstudio.com/ \"官网下载\")\n\n# 安装中文插件和C++插件\n\n# 环境搭建\n\n## 用到的手册\n\n1. [官网手册](https://code.visualstudio.com/docs/languages/cpp)\n2. [MSYS2官网手册](https://www.msys2.org/)\n3. [MinGW-w64/MSSYS2安装配置](https://blog.csdn.net/aaalg/article/details/109728475)\n\n<!--more-->\n\n\n## 具体步骤\n\n1. 下载[MSYS2](https://github.com/msys2/msys2-installer/releases/download/2022-06-03/msys2-x86_64-20220603.exe \"点击下载\")并正常安装\n2. 在下载完成后弹出的MSYS2命令行中输入 ``pacman -S  mingw-w64-x86_64-toolchain``并回车以安装 ``MinGW``\n3. 继续输入 ``pacman -S  gdb``并回车以安装 ``gdb``调试工具\n4. 输入 ``pacman -Syu``并回车以更新所有包\n5. /*此操作在添加环境变量之前可能无法正常显示版本，若显示类似“没有g++命令”，啧先进性*/按<kbd>Windows</kbd> +<kbd>r</kbd>键，在弹出的窗口输入<kbd>cmd</kbd>+<kbd>Enter</kbd>以打开终端，在弹出命令行中输入\n   ```cmd\n   gcc --version\n   g++ --version\n   gdb --version\n   ```\n   若正常显示版本，未报错，则安装正确\n6. 添加环境变量\n   1. 按 ``Windows``键并搜索 ``环境变量``，点击<kbd>环境变量(N)...</kbd>\n   2. 在 ``系统变量(S)``标题下找到并选择 ``Path``，双击 ``Path``或点击<kbd>编辑(I)...</kbd>\n   3. 在弹出窗口中点击右上角<kbd>新建(N)</kbd>，重复新建两个环境变量 ``C:\\msys64\\mingw64\\bin\\``和 ``C:\\msys64\\mingw64\\``\n   4. 点击右下方确定\n   5. 点击 ``系统变量(S)``标题内右下角<kbd>新建(W)...</kbd>并重复新建共3个系统变量\n      \n      | 变量名             | 变量值                   |\n      | :----------------- | :----------------------- |\n      | ``MINGW_HOME``     | ``C:\\msys64\\mingw32``    |\n      | ``C_INCLUDE_PATH`` | ``%MINGW_HOME%\\include`` |\n      | ``LIBRARY_PATH``   | ``%MINGW_HOME%\\lib``     |\n   6. 一直确定以退出\n7. 重启VScode\n8. 在VScode中新建一个文件夹并打开，创建一个C++程序例如：\n   ```cpp\n   #include<bits/stdc++.h>\n\n   using namespace std;\n\n   int main(){\n      cout<<\"Hello World!\"<<endl;\n      return 0;\n   }\n   ```\n9.  按<kbd>F5</kbd>并选择弹出窗口的第一项\n10. 若控制台有变化，输出\n    ```\n    Hello World!\n    \n    ```\n    则环境搭建成功\n11. 还可以右上角<kbd>运行 C/C++文件</kbd>、<kbd>调试 C/C++文件</kbd>以测试 ``g++``和 ``gdb``是否安装成功\n","tags":["计算机"],"categories":["完成"]},{"title":"重装系统","url":"/2022/09/22/重装系统/","content":"# 电脑重装了，下面记录了需要安装的软件\n\n## [Git](https://git-scm.com/downloads \"官网下载\")\n\n版本管理工具\n\n## [Neat Download Manager](http://www.neatdownloadmanager.com/index.php/en/ \"官网下载\")\n\n``Neat Download Manager``是一个多线程下载器\n\n[Edge 扩展下载](https://microsoftedge.microsoft.com/addons/detail/neatdownloadmanager-exten/pbghcbaeehloijjcebiflemhcebmlnke \"Edge扩展下载\")\n\n## [VS Code](https://code.visualstudio.com/ \"官网下载\")\n\n强大的编辑器\n\n界面左下角 ``管理``,``Sign in to Sync Setting`` 以同步数据\n\n### C++环境\n\n补丁：请忽略以下内容并参见我的[另一篇博客](https://tioibiy.github.io/2022/10/03/VScode-C-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/)\n\n#### [MinGW](https://sourceforge.net/projects/mingw/)\n\n[MinGW 教程](https://blog.csdn.net/Zhouzi_heng/article/details/115014059)\n\n[C++环境](https://zhuanlan.zhihu.com/p/87864677/)\n\n## [Hexo](https://blog.csdn.net/qq_54796785/article/details/126053172)\n\n### [Node.js](https://nodejs.org/zh-cn/)\n\n``Node.js``是一个基于 ``Chrome V8``引擎的 ``JavaScript``运行时环境\n\n## [百度网盘](http://pan.baidu.com/download#win)\n\n## [Nova Maker](https://pan.baidu.com/s/1HB95Y25_zwYk8HwYSlhpnQ?pwd=ime2&_at_=1665022649966)\n\n## [Blender](https://www.blender.org/)\n\n3D建模软件\n\n### 插件\n","tags":["计算机"],"categories":["更新中"]},{"title":"添加博客访问量","url":"/2022/09/01/添加博客访问量/","content":"# 添加博客访问量\n\n## 问题\n\n由于我使用了[AirCloud](https://github.com/aircloud/hexo-theme-aircloud)作为博客主题\n\n由于不明原因，使用[不蒜子](http://busuanzi.ibruce.info/)时显示为原[AirCloud预览博客](http://niexiaotao.cn/)访问量\n\n<!--more-->\n\n\n## 解决\n\n后选择使用[HitKounter](https://jerryzou.com/posts/introduction-to-hit-kounter-lc/)，显示正确\n\n### 全站访问量\n\n博客目录下 ``Blog\\themes\\AirCould\\layout\\_partial\\footer.ejs``文件\n\n#### 引入脚本\n\n开头添加\n\n```html\n<script src=\"https://sinacloud.net/egg-lib/hit-kounter/hit-kounter-lc-0.4.1.js\"></script>\n```\n\n#### 添加全站访问量\n\n文末\n\n```html\nCreated By <a href=\"https://hexo.io/\">Hexo</a>  Theme <a href=\"https://github.com/aircloud/hexo-theme-aircloud\">AirCloud</a></p>\n```\n\n前添加\n\n```html\n全站访问：<span data-hk-site> - </span>\n```\n\n并注释其前面原博客显示访问量的PV、UV部分\n\n```html\n<!-- <span id=\"busuanzi_container_site_pv\">\n<span id=\"busuanzi_value_site_pv\"></span>PV\n</span>\n<span id=\"busuanzi_container_site_uv\">\n    <span id=\"busuanzi_value_site_uv\"></span>UV\n</span> -->\n```\n\n::: warning\n**注意**\n只需在 ``footer.ejs``文件中引入文件，不需要再 ``post.ejs``文件中引入。否则会导致无法显示\n:::\n\n#### 效果\n\n![20220903085747](https://raw.githubusercontent.com/tioibiy/image/main/image/20220903085747.png)\n\n### 当前文章访问量\n\n博客目录下 ``Blog\\themes\\AirCould\\layout\\post.ejs``文件\n\n#### 添加单页访问量\n\n将\n\n```html\n<span class=\"attr\"><%= __('post.visit') %>：\n    <span id=\"busuanzi_value_page_pv\"></span>\n</span>\n```\n\n修改为\n\n```html\n<span class=\"attr\"><%= __('post.visit') %>：\n    <span data-hk-page=\"current\"> - </span>\n</span>\n```\n\n#### 效果\n\n![20220903085455](https://raw.githubusercontent.com/tioibiy/image/main/image/20220903085455.png)\n","tags":["计算机","博客"],"categories":["更新中"]},{"title":"Hexo中Markdown的书写规范","url":"/2022/08/31/Hexo中Markdown的书写规范/","content":"# Hexo中Markdown的书写规范\n\n使用Markdown编辑器书写完成之后进行的修改\n\n```py\n$$  -> \\$\\$\n\\\\  -> \\\\\\\\\n{{  -> { {\n}}  -> } }\n_{  -> _ {\n\\{  -> \\\\{\n\\}  -> \\\\}\n                \\scriptsize\n\\begin{}        \\begin{}\n            ->\n\\end{}          \\end{}\n```\n\n序号后若直接接代码块，如：\n\n```markdown\n1. \n2. ```\n    scripts\n    ```\n3. \n```\n\n应改为：\n\n```markdown\n1. \n2. \n    ```\n    scripts\n    ```\n3. \n```\n\nmarkdown中自定义做下-右上省略号\n\n```markdown\n$$\n\\newcommand\\iddots{\\mathinner{\n    \\kern1mu\\raise1pt{.}\n    \\kern2mu\\raise4pt{.}\n    \\kern2mu\\raise7pt{\\Rule{0pt}{7pt}{0pt}.}\n    \\kern1mu\n}}\n$$\n```\n","tags":["计算机","博客"],"categories":["更新中"]},{"title":"阻力模拟？","url":"/2022/08/30/阻力模拟？/","content":"\n# 物理作业\n\n## 比较炮弹的实际弹道与理想抛物线的差异\n\n### 推导\n\n假设质点只受重力、阻力\n\n重力加速度取$|\\vec{g}|=9.8m/{s^2}$\n质点质量为$m\\quad$\n空气阻力$f$与速度$v$的关系\n\n$$f=\\frac{1}{2}C\\rho S{ {v}^2}$$\n\n令$v^2$的系数$\\frac{1}{2}C\\rho S=k$\n\n有\n\n$$\n\\vec{G}=m\\vec{g}\n$$\n\n$$\n\\scriptsize\n\\begin{cases}|\\vec{f}|&=&k{v^2}\\\\\\frac{\\vec{f} }{|\\vec{f}|}&=&-\\frac{\\vec{v}}{|\\vec{v}|}\\end{cases}\n$$\n\n<!--more-->\n\n\n则对于时刻$t_i$，令其经历极小时间段$\\Delta t$后得到时刻为$t_{i+1}$，计算时刻$t_{i+1}$有\n\n$$\n\\vec{G_i}=\\vec{G_{i+1} }=m\\vec{g}\n$$\n\n$$\n\\scriptsize\n\\begin{cases}\n    |\\vec{f_{i+1} }|&=&k{v_{i}^2}\\\\\n    \\frac{\\vec{f_{i+1} } }{|\\vec{f_{i+1} }|}&=&-\\frac{\\vec{v_i} }{|\\vec{v_i}|}\n\\end{cases}\n$$\n\n$$\n\\vec{a_{i+1} }=\\frac{\\vec{ {F_{合} }_ {i+1} } }{m}=\\frac{\\vec{G_{i+1} }+\\vec{f_{i+1} } }{m}\n$$\n\n$$\n\\vec{v_{i+1} }=\\vec{v_{i} }+\\vec{a_{i+1} }\\cdot \\Delta t\n$$\n\n$$\n\\vec{x_{i+1} }=\\vec{x_i}+\\vec{v_{i+1} }\\cdot \\Delta t\n$$\n\n令$t_0$时\n$$\n\\scriptsize\n\\begin{cases}\n    t_0&=&0\\\\\n    \\vec{x_0}&=&\n        \\begin{bmatrix}\n            0\\\\\n            0\n        \\end{bmatrix}\\\\\n    \\vec{v_0}&=&\n        \\begin{bmatrix}\n            v_x\\\\\n            v_y\n        \\end{bmatrix}\\\\\n    \\vec{ {F_{合} }_0}&=&\\vec{G}+\\vec{f}=m\\vec{g}\\\\\n    \\vec{a_0}&=&\n        \\begin{bmatrix}\n            0\\\\\n            |\\vec{g}|\n        \\end{bmatrix}\n\\end{cases}\n$$\n\n### 实践\n\n#### Python程序\n\n```python\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nt=1\n\nprint(\"v=(x,y)=\",end='')\nv=input()[1:-1].split(',')\nv=np.array([float(v[0]),float(v[1])])\n\nprint(\"\\nm=\",end='')\nm=float(input())\n\nprint(\"\\nk=\",end='')\nk=float(input())\n\nprint(\"\\nstep=\",end='')\nstep=int(input())\n\ndef draw (flag):\n\n    vv=v\n\n    x=np.array([0,0],ndmin=2)\n\n    g=9.8\n\n    a=np.array([[0,-g],[0,0]])\n\n    for i in range(1,step+1):\n        if flag:\n            a[1]=-vv*(k**2)/m\n        vv=vv+a.sum(axis=0)*t\n        x=np.concatenate((x,[x[i-1]+vv*t]),axis=0)\n\n    x=np.array(x)\n\n    plt.plot(x[...,0],x[...,1])\n\ndraw(1)\ndraw(0)\n\nplt.show()\n```\n\n#### 输入\n\n```\n(1,2)\n1\n0.1\n100\n```\n\n```\nv=(x,y)=(1,2)\n\nm=1\n\nk=0.1\n\nstep=100\n```\n\n$$\n\\scriptsize\n\\begin{cases}\n    \\vec{v_0}=\n        \\begin{bmatrix}\n            v_x\\\\\n            v_y\n        \\end{bmatrix}=\n        \\begin{bmatrix}\n            1m/s\\\\\n            2m/s\n        \\end{bmatrix}\n    \\\\\n    m=1kg\\\\\n    k=0.1kg/m\\\\\n    缺省\\Delta t=1s\n\\end{cases}\n$$\n\n计算至$i\\le step$，即\n\n$$\ni\\in \\{i|0\\le i\\le step,i\\in N\\}\n$$\n\n时所有的$\\vec{x_i}$并绘图如下：\n\n![missile](https://raw.githubusercontent.com/tioibiy/image/main/image/missile.png)\n\n其中蓝色曲线为有阻力情况，橙色曲线为无阻力情况\n\n可以明显看出，等时间时，有阻力飞行距离更近、下落更快\n","tags":["计算机","物理"],"categories":["完成"]},{"title":"答辩","url":"/2022/08/27/答辩/","content":"# 答辩\n\n回想起来，感觉人工智能还有神经网络的超参数调整不就是以前的机器人比赛吗\n\n无非二分+枚举，找最适合的角度、距离，完成任务，拿到更高的分\n\n当我们有了更多的调试经验之后，就知道什么样的任务用什么样的参数能更快达到最佳\n\n这就是经验呗\n\n说白了，超参数还是不能靠机器学习得到\n\n还得是强人工智能啊\n","tags":["计算机","生活&吐槽"],"categories":["完成"]},{"title":"Test","url":"/2022/08/22/Test/","content":"<script type=\"text/javascript\" color=\"0,0,255\" opacity='0.7' zIndex=\"-2\" count=\"99\" src=\"dist/canvas-nest.js\"></script>\n\n<a id='test'></a>\n\n# Test\n\n# 一级标题\n\n## 二级标题\n\n### 三级标题\n\n#### 四级标题\n\n##### 五级标题\n\n###### 六级标题\n\n####### 失败的七级标题\n\n# 文字\n\n## 脚注\n\n这是第二个有注脚的文本，脚注[^1]、脚注[^2]与脚注[^3]\n[^1]:第一条注脚内容\n[^2]:第二条注脚内容\n[^3]:第三条注脚内容\n\n## `HTML`\n\n<ruby>\n拼<rt>pīn</rt>\n音<rt>yīn</rt>\n上<rt>shàng</rt>\n标<rt>biāo</rt>\n</ruby>\n\n## 文字风格\n\n|                  |      正文      |          粗体          |          斜体          |         删除线         |\n| :--------------: | :------------: | :---------------------: | :--------------------: | :---------------------: |\n|  **正文**  |      正文      |     **粗体**     |        *斜体*        |       ~~删除线~~       |\n|  **粗体**  | **粗体** |     **粗体**     | ***斜体粗体*** | **~~删除粗体~~** |\n|  **斜体**  |    *斜体*    | ***粗体斜体*** |        *斜体*        |    *~~删除斜体~~*    |\n| **删除线** |  ~~删除线~~  | ~~**删除粗体**~~ |   ~~*删除斜体*~~   |       ~~删除线~~       |\n\n## 分割线\n\n---\n\n## 按键\n\n<kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Delete</kbd>\n\n## 标签\n\n{% label default@默认 %} {% label primary@主要 %} {% label success@成功 %} {% label info@信息 %} {% label warning@警告 %} {% label danger@危险 %}\n{% label success@这是成功的信息%}\n\n## 公式\n\n### 行内公式：\n\n$t$e$s$t$s$\n\n### 大公式\n\n$$\nx=\\frac{-b \\pm {\\sqrt{ {b^2} -4ac}}}{2a}\n$$\n\n$$\n\\begin{aligned}\n(a+b)^2&=a^2+2ab+b^2\\\\\n&=a^2-2ab+b^2+4ab\\\\\n&=(a-b)^2+4ab\n\\end{aligned}\n$$\n\n# 块\n\n## 表格\n\n| col1 | col2  | col3  |\n| ---- | ----- | ----- |\n| a    | $b$ | ``c`` |\n\n## 引用\n\n> 引用块\n\n{%cq%}\n双引号引用块\n{%endcq%}\n\n<a href='#test'>文章内部引用</a>\n\n## 提示块\n\n{% note default %}\ndefault 缺省\n{% endnote %}\n\n{% note primary %}\nprimary 重要\n{% endnote %}\n\n{% note success %}\nsuccess 成功\n{% endnote %}\n\n{% note info %}\ninfo 信息\n{% endnote %}\n\n{% note warning %}\nwarning 警告\n{% endnote %}\n\n{% note danger %}\ndanger 错误\n{% endnote %}\n\n## 选项卡\n\n{% tabs tab,1 %} 名字为tab，默认在第1个选项卡，如果是-1则隐藏\n\n<!-- tab -->\n\n**选项卡 1**\n\n<!-- endtab -->\n\n<!-- tab -->\n\n**选项卡 2**\n\n<!-- endtab -->\n\n<!-- tab A -->\n\n**选项卡 3** 名字为A\n\n<!-- endtab -->\n\n{% endtabs %}\n\n## 按钮\n\n<div>{% button https://tioibit.github.io/ ,首页,home fa-fw,首页%}</div>\n\n## 代码块\n\n```c++\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n  \n    return 0;\n}\n```\n\n## 流程图代码块\n\n```mermaid\ngraph TD\n    B((开始)) -->C{判断}\n    C --  a=1 -->D[执行语句1]\n    C --  a=2  -->E[执行语句2]\n    C --  a=3 -->F[执行语句3]\n    C -- a=4  -->G[执行语句4]\n    D--> AA((结束))\n    E--> AA\n    F--> AA\n    G--> AA  \n```\n\n## $GeoGebra$嵌入块\n\n{%cq%}\n任何欣喜都会以$Ae^{-x}$消散\n——某知乎网友\n{%endcq%}\n\n<iframe scrolling=\"no\" title=\"Ae^{-x}\" src=\"https://www.geogebra.org/material/iframe/id/aaxqhvra/width/1232/height/537/border/888888/sfsb/true/smb/false/stb/false/stbh/false/ai/false/asb/false/sri/false/rc/false/ld/false/sdz/true/ctl/false\" width=\"1232px\" height=\"537px\" style=\"border:0px;\"> </iframe>\n\n# 图片\n\n![图片test](https://raw.githubusercontent.com/tioibiy/image/main/image/icon.png)\n\n# 链接\n\n[引用博客](https://dongguagua.gitee.io/archives/29bfe8c9.html)\n","tags":["计算机","博客"],"categories":["更新中"]}]